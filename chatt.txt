B
Bara lite kod
Det finns ett antal landskoder f√∂r telefonnummer
s√• skriv en funktion som tittar p√• ett nummer och kollar vilken landskod den matchar om nagon. (bara koden, inte landsnamnet)
Hur snabbt kan din algo g√∂ra detta 100000ggr
Ska leta upp koderna

M
Vad √§r formatet p√• nummren?
Kan det h√§nga att landskoden saknas?

B
Om koden saknas kan du strunta i.
S√• input √§r
/+{1-9}{0-9}*
Saknar specialtecken p√• min mobil
F√∂r mina tester anv√§nde jag bara Range(1,100000) => hashCode.toString
S√• ett g√§ng /, en siffra som inte √§r 0 och sen siffror.
Ett plus, 1-9, flera 0-9
http://country.io/phone.json
jag anv√§nde den d√§r som input efter jag rensat bort - och delat upp dom som har " and "
Min kod verkar k√∂ra det p√• 50-100 ms
I scala

M
Och sen letar du landskoder i en massa hash codes?

B
Precis, bara f√∂r skojs skull
N√•tt att fundera p√• efter lunch.

M
R√§knar du in hash-kodandet i tiden?

B
Jo.

M
Kan inte hashCode.toString inneh√•lla a-f ocks√•?

B
"asdf".hashCode
res17: Int = 3003444

M
Hur m√•nga siffror i ett nummer?
Vissa √§r ju tomma str√§ngen. Hur ska man hantera det? Alla str√§ngar matchar ju en leading empty string.
Och +och - i nummren, dom ska jag bara filtrera bort eller?
"AX": "+358-18" tolkas som "AX": "35818"

B
+ och - kan du filtrera bort (Antagligen fel i datan)
Du ska match den l√§ngsta m√∂jliga.
"+1809123" => "1809"
"+18101231" => "1"
Koden 1809 och 1 finns
men inte 1810

M
Det skulle precis bli min n√§sta fr√•ga.
100000 8-digit numbers tar 60 ms f√∂r mig. Ska experimentera mer imorgon.
Finns ju flera l√§nder som har samma kod.

B
Va?

M
Antar att man kan returnera vilken man vill d√•.

B
Du vill bara returnera koden i min spec
Med vilka √§r dubletterna

M
61 har CC, CX och AU.
Eller snarare, CC, CX och AU har alla koden 61.

B
Detta b√∂rjar likna soppan med tidzoner

M
~10 ms n√§r jag inte h√∂r hash-uppslag p√• nummer l√§ngre √§n 6.
K√∂r 4 tr√•dar.

B
Hmm, tr√•dar. K√§nder
* k√§nns fuskigt

M
Vad√•, JVM har ocks√• tr√•dar.

B
N√§, men jag t√§nkte att input √§r ett nummer i tagtt
Ska pr√∂va en grej.
Allts√• mac
         Alt space √§r n√•gon av unicode whitespace
\u00a0

M
√Ñr det ett problem?

B
Osynliga tecken som ger kompileringsfel

M
Det √§r ett problem.

B
Mitt tr√•dningsf√∂rs√∂k blev flera g√•nger l√•ngsammare

M
Det √§r ocks√• ett problem.

B
Njae, jag f√∂rs√∂kte anv√§nda en tr√•d per storlek
S√• det blev f√∂r mycket kommunikation
S√• ist√§llet f√∂r  n√•gra hashmapsindexeringar f√∂rs√∂kte jag kolla alla samtidigt
Men det √§r bra att veta.

M
Var skedde kommunikationen?

B
Jag anv√§nde actors.
S√• mailboxes och futures

M
Jag f√∂rs√∂ker bygga en trie. Inte trivialt.

B
Min bygges med noderna
Valid(array(10))
InValid(array(10))

Invalid(1) 
  1 -> Valid(1, 3)
       1 -> Invalid(2, 3)
       3 -> Valid()
Om du f√∂rst√•r?

M
Nej.

B
S√• rotnoden √§r ogiltig f√∂r det skulle motsvara en tom str√§ng.

M
Vad betyder # i parantesen?
1:valid
11: invalid
13: valid

B
Rotnoden √§r en
Invalid(1,2,3,4,5,6,7,8,9) d.v.s den inneh√•ller en array med referenser till noder f√∂r 1-9

M
Ok, s√• under 11 finns 112 och 113.
Fast dom skrev du inte ut.

B
Mina noder inneh√•ller ingen information f√∂rutom ytterligare barn
Och nej, den var inte korrekt
Utan actors blir koden 3 ggr snabbare.
(d.v.s. jag anv√§nder FutureTask
)
haha
du jag t√§nkte inte ens p√• en sekund att vi har helt olika processorer...

M
Jo, vi m√•ste testa varandras sen.
Ska fara m√∂ta emma nu s√• det kommer nog inte bli n√•tt mer kodande ikv√§ll...

B
Okej! Ses senare!
Om du skickar din c++ kod borde jag kunna kompilera den och se

M
Kanske skulle s√§tta upp ett projekt p√• GitHub f√∂r det h√§r.
Kommer det n√•n fil?

B
inte vad jag ser
http://www.filedropper.com/ kanske?

M
http://www.filedropper.com/countrynrhash

B
kompilera med?
Took 19.3968 ms
Bertils-MBP:Downloads bernil$ ./a.out 
Took 18.833 ms
Bertils-MBP:Downloads bernil$ ./a.out 
Took 19.8024 ms
Bertils-MBP:Downloads bernil$ 
Bertils-MBP:Downloads bernil$ ./a.out 
Took 19.2425 ms
Bertils-MBP:Downloads bernil$ ./a.out 
Took 21.2012 ms
Bertils-MBP:Downloads bernil$ ./a.out 
Took 19.1565 ms
Bertils-MBP:Downloads bernil$ 

M
/usr/bin/c++ -O3 -DNDEBUG -Wall -std=gnu++11 -pthread

B
Took 7.63213 ms
Bertils-MBP:Downloads bernil$ ./a.out 
Took 7.54805 ms
Bertils-MBP:Downloads bernil$ ./a.out 
Took 7.49514 ms
S√§tter man multihreaded = 0 kompilerar inte koden

M
Det var mer lafom tider. Borde kompilera... vad s√§ger den?

B
Jag √§r nere p√•  time: 32.611721ms med singletr√•den
 error: no matching function for call to 'generateNumber
484:9
countryNr_hash.cpp:374:6: note: candidate function not viable: requires 2 arguments, but 1 was provided
Kanske vettigare
Jag stoppar dit en rand

M
Ok

B
Building phone book took 5.755e-05 s
100000 numbers took 0.035821 s
Found 81722 matches.

B
S√• f√• √§r vi typ lika?
599.467027ms
Typ lika.
Googles ger 600ms

M
Googles?

B
libphonenumber
Min multitr√•dade √§r mycket l√•ngsammare √§n din
15ms typ, med 4 tr√•dar
Det √§r en coinflip om jag vinner n√•got p√• att k√∂ra den i tr√•dar üòÆ

M
Kanske kan tr√•da p√• n√•got annat s√§tt som fungerar b√§ttre. N√•n producer/consumer variant kanske.
En smiley.

B
Med fler siffor blir min kod mer stabil.
10 +- 2 ms om den f√•r v√§rma upp ordentligt
148.416376ms
29.831113ms
30.122774ms
26.232864ms
12.592177ms
S√• ser tiderna fr√•n kall jvm till varm jvm ut

M
√Ñr det JIT-en som kommer in och optimerar b√§ttre?

K√∂r du samma range(1,100000) om och om igen i en loop?
Vad h√§nder om man g√∂r samma sak med min?

B
Jag trycker pilupp i min REPL

M
ok

B
Din √§r mer som en klocka.

M
Antar att det √§r samma sak.

B
30ms +- 5
nej
32 +- 2
Imorgon ska jag skriva i rust och kolla om jag kan komma ner i din tid
Men singeltr√•dade verker vi √§nd√• ha r√§tt lika

M
Ska bli sp√§nnande att se om jag f√•r till n√•gon trie.

B
Men jag f√∂rst√•r inte varf√∂r jag inte f√•r en b√§ttre speedup av att tr√•da 
Range(0, 100000).par.flatMap(x => matchByTree("+" + x.hashCode()))
Enkelt att parallelisera.
Har du f√•tt tid att kika p√• att bygga en trie

M
H√•ller p√• precis nu.

B
‚ò∫

M
Men jag √§r nog inte i toppform i helgen. Tog mig typ en kvart att skriva en in-place prefix sum.

B
"in-place prefix sum" huh+

M
Men f√∂rbannat.
H√§r jag jag suttit och skrivit AVX2-intrinsics och s√• uppt√§cker jag att min processor inte st√∂djer det.
B√∂rar bli lite v√§l skakiga siffror s√• jag gjorde en mean av 1000 k√∂rningar av varje i Octave:

>> load 'trie.dat';
>> mean(trie)
ans = 3.2991

>> load 'hash.dat'
>> mean(hash)
ans = 5.7447

Har har kodat p√• en hel del nu och har inga unittester s√• jag vet inte ens om den g√∂r r√§tt fortfarande.
Hittade tv√• buggar i min trie-implementation.
Den f√∂rsta var egentligen i lastbalaseringen f√∂r tr√•darna och gjorde att de blev idle trots att det fanns jobb kvar att g√∂ra.

Den andra var att den fortsatte s√∂ka ner i tr√§det √§ven n√§r det inte beh√∂vdes.

B
3ms...

M
Det var inte illa.

B
Alltsa din

M
Jag kommer under 2ms n√•n g√•ng ibland med : ~4 tr√•dar.
Lite olika fr√•n k√∂rning till k√∂rning.

B
Det √§r tiden det tar f√∂r mig att iterera √∂ver hashcod

M
0.17% av L1 cache loads √§r cache misses. Det √§r inte d√•ligt.
Funkar det att k√∂ra perf p√• din? Med VM och allt t√§nker jag. Borde v√§l fungera √§nd√•?
perf stat -d <your command>

B
Undra om det finns verktyg som spelar in ett programs minnesanv√§ndning f√∂r att k√∂ras samtidig
Som perftester

M
Man vill nog testa en sak i taget. Inte prestanda och minnesanv√§ndning sammtidigt.

B
Jag t√§nker att prestandan blir ju p√•verkad av vad resten av programmet g√∂r

M
Jo, f√∂rst√•ss. 
Massif √§r en heap profiler, om det √§r vad du √§r ute efter. Men eftersom du lever i en VM s√• vill du nog anv√§nda VM-specifika verktyg.
F√∂rst√•r inte riktigt vad du vill m√§ta och samtidigt med vad?

B
Jag t√§nker att en algoritm kanske kan f√∂rst√∂ra olika mycket f√∂r resten av koden. Men det g√∂r man ju b√§st med en profiler j√§mf√∂rt p√• tv√• git branches

M
Hur stor del av tiden har du i .hashCode och hurstor del √§r faktiska uppslag?
https://drive.google.com/file/d/0ByfCQ4MBd1l0MFpidTFwV1lnN19yQ3hJdmw2eWN5NzVta0E0/view?usp=drivesdk
Problem med CrashPlan?
